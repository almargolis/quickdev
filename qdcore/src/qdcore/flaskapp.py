"""
qdcore.flaskapp - Flask application factory generation

Generates qd_create_app.py and .wsgi files from repos.db metadata.
Each QD Flask package declares its init function, parameters, and
priority in its qd_conf.yaml flask: section. The generator reads
these declarations and produces a working Flask application factory.
"""

import json
import os
import sys


class FlaskAppGenerator:
    """
    Generates qd_create_app.py and .wsgi files from repos.db metadata.

    Reads flask_init table (populated from qd_conf.yaml flask: sections)
    to produce:
      1. qd_create_app.py with qd_init_app(app) and create_app()
      2. <prefix>.wsgi for Apache mod_wsgi deployment
    """

    def __init__(self, repo_scanner, qdsite_dpath, venv_dpath=None,
                 qdsite_prefix=None, conf=None):
        """
        Args:
            repo_scanner: RepoScanner instance with populated database
            qdsite_dpath: Path to site root directory
            venv_dpath: Path to virtual environment
            qdsite_prefix: Site acronym/prefix (used for .wsgi filename)
            conf: QdConf instance for resolving conf_answer params
        """
        self.repo_scanner = repo_scanner
        self.qdsite_dpath = qdsite_dpath
        self.venv_dpath = venv_dpath
        self.qdsite_prefix = qdsite_prefix or 'app'
        self.conf = conf

    def generate_create_app(self):
        """
        Generate qd_create_app.py at site root.

        Returns:
            Path to the generated file, or None if no Flask packages
        """
        init_sequence = self.repo_scanner.get_flask_init_sequence()
        if not init_sequence:
            return None

        answers = self.repo_scanner.get_answers()
        config_module = answers.get('flask.config_module')
        site_blueprints = self._get_site_blueprints(answers)

        lines = []
        lines.append('"""')
        lines.append('Flask application factory.')
        lines.append('')
        lines.append('Auto-generated by QuickDev. Do not edit directly.')
        lines.append('Regenerated on each QdStart run from qd_conf.yaml'
                     ' declarations.')
        lines.append('')
        lines.append('To customize, create site_hooks.py in the site root'
                     ' with:')
        lines.append('  - configure_app(app)  '
                     '  called before init functions')
        lines.append('  - register_error_handlers(app)  '
                     '  called after init')
        lines.append('  - register_context_processors(app)  '
                     '  called after init')
        lines.append('  - register_cli_commands(app)  '
                     '  called after init')
        lines.append('"""')
        lines.append('')
        lines.append('import os')
        lines.append('import sys')
        lines.append('')
        lines.append(
            'SITE_ROOT = os.path.dirname(os.path.abspath(__file__))')
        lines.append('if SITE_ROOT not in sys.path:')
        lines.append('    sys.path.insert(0, SITE_ROOT)')
        lines.append('')
        lines.append('')

        # --- qd_init_app ---
        lines.append('def qd_init_app(app):')
        lines.append('    """Initialize all enabled QD packages on a'
                     ' Flask app."""')
        lines.append('    _hooks = _load_hooks()')
        lines.append("    if hasattr(_hooks, 'configure_app'):")
        lines.append('        _hooks.configure_app(app)')
        lines.append('')

        # Emit init calls ordered by priority
        for entry in init_sequence:
            lines.append(f'    # --- Priority {entry["priority"]}:'
                         f' {entry["module"]}.{entry["function"]} ---')
            lines.append(
                f'    from {entry["module"]} import {entry["function"]}')

            param_str = self._build_param_string(entry.get('params'),
                                                 answers)
            if param_str:
                lines.append(
                    f'    {entry["function"]}(app, {param_str})')
            else:
                lines.append(f'    {entry["function"]}(app)')
            lines.append('')

        # Emit site blueprint registration
        if site_blueprints:
            lines.append('    # --- Site Blueprints ---')
            # Group by module for cleaner imports
            by_module = {}
            for bp in site_blueprints:
                mod = bp['module']
                by_module.setdefault(mod, []).append(bp['name'])
            for mod, names in by_module.items():
                names_str = ', '.join(names)
                lines.append(f'    from {mod} import {names_str}')
            for bp in site_blueprints:
                lines.append(
                    f'    app.register_blueprint({bp["name"]})')
            lines.append('')

        # Emit post-init hooks
        lines.append('    # --- Post-init hooks ---')
        lines.append("    if hasattr(_hooks, 'register_error_handlers'):")
        lines.append('        _hooks.register_error_handlers(app)')
        lines.append(
            "    if hasattr(_hooks, 'register_context_processors'):")
        lines.append('        _hooks.register_context_processors(app)')
        lines.append("    if hasattr(_hooks, 'register_cli_commands'):")
        lines.append('        _hooks.register_cli_commands(app)')
        lines.append('')
        lines.append('')

        # --- create_app ---
        lines.append('def create_app(config_class=None):')
        lines.append('    """Standalone Flask application factory.')
        lines.append('')
        lines.append('    Use with: FLASK_APP=qd_create_app')
        lines.append('    """')
        lines.append('    from flask import Flask')
        lines.append('')

        if config_module:
            mod_path, cls_name = config_module.rsplit('.', 1)
            lines.append('    if config_class is None:')
            lines.append(
                f'        from {mod_path} import {cls_name}')
            lines.append(f'        config_class = {cls_name}')
        else:
            lines.append('    # No config_module declared in'
                         ' qd_conf.yaml')
            lines.append('    # Set defaults from environment')

        lines.append('')
        lines.append("    app = Flask(__name__)")
        lines.append('')

        if config_module:
            lines.append('    if config_class:')
            lines.append('        app.config.from_object(config_class)')
        else:
            lines.append("    app.config.setdefault('SECRET_KEY',")
            lines.append("        os.environ.get('SECRET_KEY',"
                         " 'dev-key-change-in-production'))")
            lines.append(
                "    app.config.setdefault('SQLALCHEMY_DATABASE_URI',")
            lines.append(
                "        os.environ.get('DATABASE_URL',"
                " 'sqlite:///app.db'))")
            lines.append(
                "    app.config.setdefault("
                "'SQLALCHEMY_TRACK_MODIFICATIONS', False)")

        lines.append('')
        lines.append('    qd_init_app(app)')
        lines.append('    return app')
        lines.append('')
        lines.append('')

        # --- _load_hooks ---
        lines.append('def _load_hooks():')
        lines.append(
            '    """Load site_hooks.py from site root if it exists."""')
        lines.append(
            "    hooks_path = os.path.join(SITE_ROOT, 'site_hooks.py')")
        lines.append('    if os.path.isfile(hooks_path):')
        lines.append('        import importlib.util')
        lines.append(
            "        spec = importlib.util.spec_from_file_location("
            "'site_hooks', hooks_path)")
        lines.append(
            '        module = importlib.util.module_from_spec(spec)')
        lines.append('        spec.loader.exec_module(module)')
        lines.append('        return module')
        lines.append('')
        lines.append('    class _NoHooks:')
        lines.append('        pass')
        lines.append('    return _NoHooks()')
        lines.append('')
        lines.append('')

        # --- __main__ ---
        lines.append("if __name__ == '__main__':")
        lines.append('    create_app().run(debug=True)')
        lines.append('')

        content = '\n'.join(lines)
        output_path = os.path.join(self.qdsite_dpath, 'qd_create_app.py')
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

        return output_path

    def generate_wsgi(self):
        """
        Generate <prefix>.wsgi at site root.

        Returns:
            Path to the generated file, or None if prerequisites missing
        """
        if not self.venv_dpath:
            return None

        # Find the site-packages directory for the venv
        site_packages = self._find_site_packages(self.venv_dpath)

        lines = []
        lines.append('#!/usr/bin/python3')
        lines.append('"""')
        lines.append(
            f'WSGI entry point for {self.qdsite_prefix}.')
        lines.append('')
        lines.append('Auto-generated by QuickDev.')
        lines.append('"""')
        lines.append('import sys')
        lines.append('import os')
        lines.append('')
        lines.append(f"site_root = '{self.qdsite_dpath}'")

        if site_packages:
            lines.append(
                f"venv_site_pkgs = '{site_packages}'")
            lines.append('if venv_site_pkgs not in sys.path:')
            lines.append('    sys.path.insert(0, venv_site_pkgs)')
        else:
            # Fallback: use activate_this.py if available
            lines.append(
                f"venv_path = '{self.venv_dpath}'")
            lines.append("activate_this = os.path.join("
                         "venv_path, 'bin', 'activate_this.py')")
            lines.append('if os.path.exists(activate_this):')
            lines.append("    exec(open(activate_this).read(),"
                         " dict(__file__=activate_this))")

        lines.append('if site_root not in sys.path:')
        lines.append('    sys.path.insert(0, site_root)')
        lines.append('')
        lines.append('from qd_create_app import create_app')
        lines.append('application = create_app()')
        lines.append('')

        content = '\n'.join(lines)
        filename = f'{self.qdsite_prefix}.wsgi'
        output_path = os.path.join(self.qdsite_dpath, filename)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

        return output_path

    def _build_param_string(self, params, answers):
        """
        Build a Python parameter string from param specs.

        Args:
            params: Dict of param_name -> param_spec, or None
            answers: Dict of conf_key -> conf_value from repo_scanner

        Returns:
            String like "roles=['admin', 'editor'], login_view='auth.login'"
            or empty string if no params
        """
        if not params:
            return ''

        parts = []
        for param_name, spec in params.items():
            value_str = self._resolve_param(spec, answers)
            parts.append(f'{param_name}={value_str}')

        return ', '.join(parts)

    def _resolve_param(self, spec, answers):
        """
        Resolve a parameter specification to a Python expression string.

        Args:
            spec: Dict with source, key, type, default
            answers: Dict of conf_key -> conf_value

        Returns:
            String containing valid Python expression
        """
        if not isinstance(spec, dict):
            return repr(spec)

        source = spec.get('source', 'answer')
        default = spec.get('default', 'None')

        if source == 'answer':
            key = spec.get('key', '')
            raw_value = answers.get(key)
            if raw_value is not None:
                declared_type = spec.get('type', 'string')
                return self._format_value(raw_value, declared_type)
            return default

        if source == 'runtime':
            return spec.get('expression', 'None')

        return default

    def _format_value(self, raw_value, declared_type):
        """
        Convert a raw value (from YAML/conf) to a Python literal string.

        Args:
            raw_value: The raw string or value from conf_answers
            declared_type: One of 'string', 'list', 'dict', 'boolean', 'int'

        Returns:
            String containing valid Python expression
        """
        if declared_type == 'list':
            # Handle comma-separated string -> Python list
            if isinstance(raw_value, str):
                items = [item.strip() for item in raw_value.split(',')
                         if item.strip()]
                return repr(items)
            if isinstance(raw_value, list):
                return repr(raw_value)
            return repr([raw_value])

        if declared_type == 'dict':
            if isinstance(raw_value, dict):
                return repr(raw_value)
            # Try parsing as JSON
            try:
                parsed = json.loads(raw_value)
                return repr(parsed)
            except (json.JSONDecodeError, TypeError):
                return repr(raw_value)

        if declared_type == 'boolean':
            if isinstance(raw_value, bool):
                return repr(raw_value)
            val = str(raw_value).lower().strip()
            return 'True' if val in ('true', 'yes', '1') else 'False'

        if declared_type == 'int':
            try:
                return str(int(raw_value))
            except (ValueError, TypeError):
                return repr(raw_value)

        # Default: string
        return repr(str(raw_value))

    def _get_site_blueprints(self, answers):
        """
        Get site blueprint declarations from conf_answers.

        Args:
            answers: Dict of conf_key -> conf_value

        Returns:
            List of dicts with 'module' and 'name' keys, or empty list
        """
        raw = answers.get('flask.site_blueprints')
        if not raw:
            return []
        try:
            return json.loads(raw)
        except (json.JSONDecodeError, TypeError):
            return []

    def _find_site_packages(self, venv_path):
        """
        Find the site-packages directory inside a virtualenv.

        Args:
            venv_path: Path to virtual environment root

        Returns:
            Path to site-packages directory, or None
        """
        lib_path = os.path.join(venv_path, 'lib')
        if not os.path.isdir(lib_path):
            return None

        for entry in os.listdir(lib_path):
            if entry.startswith('python'):
                sp = os.path.join(lib_path, entry, 'site-packages')
                if os.path.isdir(sp):
                    return sp

        return None
