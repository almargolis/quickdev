"""
CRUD API Example - Using XSynth for Data Models

This demonstrates how XSynth eliminates repetitive CRUD code.
Define your fields once, generate all the boilerplate.
"""

# AUTO-GENERATED by XSynth from product_model.xpy
# DO NOT EDIT - Edit the .xpy file instead

from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()


class Product:
    """Product model - auto-generated CRUD methods."""

    __tablename__ = 'products'

    # Fields defined once
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False)
    quantity = db.Column(db.Integer, default=0)
    category = db.Column(db.String(50))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        """Convert to dictionary - fields auto-expanded."""
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'price': self.price,
            'quantity': self.quantity,
            'category': self.category,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }

    @classmethod
    def from_dict(cls, data):
        """Create from dictionary with validation."""
        # Auto-generated validation for required fields
        required = ['name', 'price']
        for field in required:
            if field not in data:
                raise ValueError(f"Missing required field: {field}")

        return cls(
            name=data.get('name'),
            description=data.get('description'),
            price=data.get('price'),
            quantity=data.get('quantity', 0),
            category=data.get('category'),
        )

    @classmethod
    def search(cls, query_string):
        """Search across searchable fields."""
        # Auto-generated from SEARCHABLE_FIELDS
        search = f"%{query_string}%"
        return cls.query.filter(
            db.or_(
                cls.name.ilike(search),
                cls.description.ilike(search),
                cls.category.ilike(search),
            )
        ).all()

    def __repr__(self):
        return f"<Product {self.id}: {self.name}>"


# The power of XSynth:
# - Change FIELDS definition → regenerate to_dict(), from_dict(), etc.
# - Change REQUIRED_FIELDS → regenerate validation
# - Change SEARCHABLE_FIELDS → regenerate search()
# - One source of truth for the entire model
